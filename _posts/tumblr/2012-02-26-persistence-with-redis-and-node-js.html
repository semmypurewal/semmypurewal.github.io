---
layout: post
title: Persistence with Redis and Node.js
date: '2012-02-26T19:15:00-08:00'
tags:
- nodejs
- redis
- db
tumblr_url: http://blog.semmy.me/post/18348581070/persistence-with-redis-and-node-js
---
<p>In my previous two blog posts, we <a target="_blank" href="http://blog.semmy.me/2012/02/07/node-js-getting-started-with-vagrant.html">set up a Node.js development environment</a> using Vagrant and Chef, and then we <a target="_blank" href="http://blog.semmy.me/2012/02/10/streaming-twitter-with-ntwitter-and-node-js.html">used the ntwitter module to connect to Twitter&#8217;s streaming API</a>. Next, we&#8217;d like to store some information on the server and then display this information to the user. In this post, we&#8217;re going to focus on the former: we&#8217;ll write some code that keeps tracks some aggregate information about the tweets using <a target="_blank" href="http://redis.io">Redis</a>. I&#8217;ll assume you&#8217;ve worked your way through the previous two tutorials.</p>

<p>Redis is a key-value store; some refer to it as a data-structure server. These are different from traditional databases in that they store information in volatile memory (keeping it very fast)  and also allow you to organize data into traditional structures (hashes, lists, sets, etc). It is perfect for storing data that needs to be accessed quickly (like session information) or for caching to improve the response time of your applications.</p>

<p>Our goal is to keep track of the number of times each of the following words appear: &#8216;awesome,&#8217; &#8216;cool,&#8217; &#8216;rad,&#8217; &#8216;gnarly,&#8217; and &#8216;groovy.&#8217; To do this, we&#8217;ll simply use a key for each of the words, and each value will be an integer representing the number of times the word appears.</p>

<p>To get a feeling for how redis works, let&#8217;s interact with it via the command line client. Fire up vagrant and ssh into the box</p>

<pre class="code">
$ vagrant up
$ vagrant ssh
</pre>

<p>Now we should be logged into our virtual machine where redis is already installed and configured. The following command starts up the redis client and creates a key for &#8216;awesome&#8217; and sets its value to 0.</p>

<pre class="code">
$ redis-cli
redis 127.0.0.1:6379&gt; set awesome 0
</pre>

<p>If all goes well, redis should respond with &#8216;OK.&#8217; We can check the value of the key by using the <tt>get</tt> command, and we can increment it by using the <tt>incr</tt> command.</p>

<pre class="code">
redis 127.0.0.1:6379&gt; get awesome
"0"
redis 127.0.0.1:6379&gt; incr awesome
(integer) 1
redis 127.0.0.1:6379&gt; incr awesome
(integer) 2
redis 127.0.0.1:6379&gt; get awesome
"2"
</pre>

<p>To exit out of the interactive redis client, you can type &#8216;exit&#8217; or press CTRL-D to send an End-Of-File character to the process. If you want to practice and learn more about redis, try out this outstanding <a target="_blank" href="http://try.redis-db.com/">interactive redis tutorial</a>.</p>

<p>So now we know how to create a key for each word and then increment the value interactively, but we&#8217;d like to be able to do it programmatically in Node. To do this, we&#8217;ll need to install the redis module via npm. To do this enter your app directory on your virtual machine and install redis.</p>

<pre class="code">
$ cd app
$ npm install redis
</pre>

<p>Next, on your host machine, open the twitter.js file that we created in the last tutorial. It should be in the app directory, and you can open it in any text editor you&#8217;d like. Modify it so it looks like this:</p>

<pre class="code">var twitter = require('ntwitter');
var redis = require('redis');
var credentials = require('./credentials.js');

//create redis client                                                                                                                                                                                                                       
var client = redis.createClient();

//if the 'awesome' key doesn't exist, create it                                                                                                                                                                                             
client.exists('awesome', function(error, exists) {
    if(error) {
        console.log('ERROR: '+error);
    } else if(!exists) {
        client.set('awesome', 0); //create the awesome key
    };
});

var t = new twitter({
    consumer_key: credentials.consumer_key,
    consumer_secret: credentials.consumer_secret,
    access_token_key: credentials.access_token_key,
    access_token_secret: credentials.access_token_secret
});

t.stream(
    'statuses/filter',
    { track: ['awesome', 'cool', 'rad', 'gnarly', 'groovy'] },
    function(stream) {
        stream.on('data', function(tweet) {
            console.log(tweet.text);
            //if awesome is in the tweet text, increment the counter                                                                                                                                                                        
            if(tweet.text.match(/awesome/)) {
                client.incr('awesome');
            }
        });
    }
);</pre>

The new lines in this program illustrate the non-blocking, event-driven nature of Node.js.  If you&#8217;re coming from a more traditional programming background, you might be more comfortable with this approach checking the existence of the awesome key:

<pre class="code">
var exists = client.exists('awesome'); //returns true if the key exists
if(!exists) {
    client.set('awesome', 0);
};</pre>

<p>In the first line of this code, note that the program halts until the Redis (or other DB) client returns the result of the query. So in the second line (the <tt>if</tt> statement), we can use the boolean value.</p>

<p>Node&#8217;s approach is different. It queries Redis, and while it&#8217;s waiting for the response, it continues executing the remainder of the program. That&#8217;s why we send in an anonymous function as a callback to the query &#8212; this tells node what to do when Redis returns with an answer. The variables in our anonymous function take on the actual values when Redis returns; they act like the left hand side of the assignment operator in the blocking approach.</p>

<p>So the non-blocking approach ends up looking like:</p>

<pre class="code">//redis gives a value to error and exists                                                                                                                                                                                          
client.exists('awesome', function(error, exists) {
    //if error is defined, then there was probably some
    //problem connecting to redis
    if(error) {
        console.log('ERROR: '+error);
    }
    //otherwise exists will be available, and we can do something with it
    else if(!exists) {
        client.set('awesome', 0); //create the awesome key
    };
});</pre>

<p>You can now modify this code so it keeps track of the counts for all of the words that the ntwitter module is watching. This program will be our background worker; my next blog post will show you how to use second Node.js program to create a web server that will allow us to share these counts on a web page. We&#8217;ll use the <a href="http://expressjs.com/" target="_blank">Express</a> web framework to do this.</p>
