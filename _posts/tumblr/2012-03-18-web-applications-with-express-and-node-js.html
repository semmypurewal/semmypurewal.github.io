---
layout: post
title: Web Applications with Express and Node.js
date: '2012-03-18T17:56:00-07:00'
tags:
- nodejs
- express
tumblr_url: http://blog.semmy.me/post/19536526990/web-applications-with-express-and-node-js
---
<p>If you worked through the previous tutorials, I hope that you managed to <a href="http://blog.semmy.me/2012/02/07/node-js-getting-started-with-vagrant.html" target="_blank">create a basic node.js application</a>, <a href="http://blog.semmy.me/2012/02/10/streaming-twitter-with-ntwitter-and-node-js.html" target="_blank">stream data from twitter</a>, and, finally, <a href="http://blog.semmy.me/2012/02/26/persistence-with-redis-and-node-js.html">store aggregate information about that data in a redis data store</a>. To serve up this data in an application, we used the http library to serve up web pages. So if you also completed the suggested exercise in the previous tutorial, your code might look something like this:</p>

<pre class="code">var server = http.createServer(function (req, res) {
    client.mget(['awesome','cool'], function(err, results) {
	var response = '&lt;b&gt;Hello from my http server!!&lt;/b&gt;';
	response += '&lt;p&gt;Total awesome: ' + results[0] + '&lt;/p&gt;';
	response += '&lt;p&gt;Total cool: ' + results[1] + '&lt;/p&gt;';
	res.writeHead(200, {'Content-Type': 'text/html'});
	res.end(response);
    });
}).listen(3000);</pre>

<p>Note that we used redis&#8217;s <tt>mget</tt> command to send in an array of keys and get back an array of values. This isn&#8217;t something that I described in my previous blog posts, but it is described in the <a href="http://redis.io/commands" target="_blank">redis command documentation</a>. If you continue to use redis, it would be helpful to become familiar with some of the commands that redis offers.</p>

<p>Now suppose we wanted to actually style this code and include some javascript. Notice how quickly this can add complexity to our callback function:</p>

<pre class="code"> var server = http.createServer(function (req, res) {
    client.mget(['awesome','cool'], function(err, results) {
        var response += '&lt;script&gt;'
        response += '//script stuff here'
        response += '&lt;/script&gt;';
        response += '&lt;style&gt;'
        response += '//style stuff here'
        response += '&lt;/style&gt;';
        response += '&lt;b&gt;Hello from my http server!!&lt;/b&gt; &lt;br/&gt;';
	response += '&lt;p&gt;Total awesome: ' + results[0] + '&lt;/p&gt;';
	response += '&lt;p&gt;Total cool: ' + results[1] + '&lt;/p&gt;';
        res.writeHead(200, {'Content-Type': 'text/html'});
        res.end(response);
    });
}).listen(3000); </pre>

<p>This is definitely an unsustainable approach. In fact, if you&#8217;re coming from an apache or rails background, this likely seems a little ridiculous. Does this mean we need to hard-code static html files?</p>

<p>Well, the answer is yes and no. If you stick with the core node.js API, there is no built-in method for serving up static html files (at least not to my knowledge). There&#8217;s also no built-in method for serving up html templates and partial views like in rails.</p>

<p>That&#8217;s where the <a href="http://" target="_blank">Express</a> web framework comes in. Express is a web application framework that is inspired by the <a href="http://sinatrarb.com" target="_blank">Sinatra</a> framework for Ruby. It provides a layer on top of the http library that provides these features among others. In this post, I&#8217;ll describe how to install express and create an Express application. Then I&#8217;ll talk a little bit about how to edit and create routes in your application.</p>

<p>If you&#8217;re using vagrant, start by firing up your vagrant virtual machine and ssh&#8217;ing into it. Next, you&#8217;ll want to install the express binary globally using npm. We haven&#8217;t done this type of npm install before; the difference is that we have to use <tt>sudo</tt> (since this will install express into a system directory) and add the <tt>-g</tt> flag. Since this is a global operation, it doesn&#8217;t matter which directory you are in.</p>

<pre class="code">$ sudo npm install -g express</pre>

<p>Now we can easily bootstrap an express application. Make sure you&#8217;re in the app directory of your virtual machine. You can verify this by typing <tt>pwd</tt> (print working directory) at the command line. Your output should look something like this:</p>

<pre class="code">$ pwd
/home/vagrant/app</pre>

<p>If you&#8217;re not in <tt>/home/vagrant/app</tt>, go ahead and use <tt>cd</tt> to get there. Now we&#8217;ll create a new application using the express binary.</p>

<pre class="code">$ express
destination is not empty, continue? Y

   create : .
   create : ./package.json
   create : ./app.js
   create : ./public
   create : ./public/javascripts
   create : ./public/images
   create : ./public/stylesheets
   create : ./public/stylesheets/style.css
   create : ./routes
   create : ./routes/index.js
   create : ./views
   create : ./views/layout.jade
   create : ./views/index.jade

   dont forget to install dependencies:
   $ cd . &amp;&amp; npm install</pre>

<p>Note that express created a series of files, including a file of required dependencies file called <tt>package.json</tt>. Thanks to that file, we can install all of the new required dependencies by making sure we&#8217;re in the directory with <tt>package.json</tt> and using</p>

<pre class="code">npm install</pre>

<p>Now you&#8217;ll have the Express file structure in your app directory, and your default express application should be in the file called <tt>app.js</tt>. You can run your express application by running the following command:</p>

<pre class="code">node app.js</pre>

<p>Now pointing your browser to localhost:3000, you should see the &#8216;Welcome to Express&#8217; message. Kill your server by typing CTRL-C, and let&#8217;s take a look at the directory structure that express created. Type <tt>ls</tt> at the command prompt and, in addition to server.js, twitter.js and credentials.js, you should see all of the following files/directories:</p>

<ul><li><tt>app.js</tt>: the auto-generated express application</li>
  <li><tt>node_modules</tt>: your application&#8217;s module dependencies</li>
  <li><tt>package.json</tt>: a file that specifies your application&#8217;s dependencies</li>
  <li><tt>public</tt>: your static client-side files (usually stylesheets and client-side JavaScript files, but it sometimes includes html files)</li>
  <li><tt>routes</tt>: callbacks for the various routes in your application</li>
  <li><tt>views</tt>: your html templates</li>
</ul><p>For this blog post, we&#8217;re primarily interested in the <tt>app.js</tt> file and the <tt>routes</tt> directory. Open up the <tt>app.js</tt> file and take a look at the section that looks like</p>

<pre class="code">// Routes                                                                                                                                                                          

app.get('/', routes.index);</pre>

<p>Routes are the URL paths in your application. For example, let&#8217;s suppose you had a web application located at mygreatwebapp.com. If your application allowed for multiple users, you might want the URL for their user profile to appear at mygreatwebapp.com/[user]. Both github and twitter do this: visit github.com/semmypurewal or twitter.com/semmypurewal. In this code, we have a single route that is just the index of the page. The callback is defined in a file in the routes directory, but we&#8217;ll take a look at that in a moment.</p>

<p>Start up your application and visit localhost:3000. You should get the same &#8216;Welcome to Express&#8217; message as before, because that&#8217;s the &#8216;/&#8217; route that is defined above. Now try to visit localhost:3000/semmypurewal. You should get an error that says something like &#8216;Cannot GET /semmypurewal.&#8217; So how do we add a new route to handle that type of request? Modify the code above to add a route like this one:</p>

<pre class="code">// Routes                                                                                                                                                                          
app.get('/', routes.index);

app.get('/semmypurewal', function(req, res) {
    res.send('Welcome to the profile of Semmy Purewal');
});</pre>

<p>Now restart your app, and point your browser to localhost:3000. You&#8217;ll see the same &#8216;Welcome to Express&#8217; screen as before. But if you point your browser to localhost:3000/semmypurewal, you&#8217;ll now see the application handles the request as you describe in your callback function.</p>

<p>This is great, but obviously, if our application has over a million users it would be tedious to create a separate callback for each one. But we can easily generate an infinite number of routes by using variables. For example, try adding a route like this:</p>

<pre class="code">// Routes                                                                                                                                                                          
app.get('/', routes.index);

app.get('/semmypurewal', function(req, res) {
    res.send('Welcome to the profile of Semmy Purewal');
});

app.get('/users/:user', function(req, res) {
    res.send('Welcome to the profile of ' + req.params.user + '!');
});</pre>

<p>Now you can point your browser to localhost:3000/users/semmypurewal or localhost:3000/users/helloworld. In fact, it will respond to any user name. Typically, in the callback for something like this, we would check to see if the username exists and if it does, we would render the page, otherwise we would send a message like &#8216;that user was not found!&#8217; For now, we&#8217;ll keep things simple, though.</p>

<p>But because the code in our callback has the propensity to callback become complicated it&#8217;s a good idea to move it into a different file. It&#8217;s best to leave express&#8217;s <tt>app.js</tt> file for specifying the configuration of the application along with its routes. Open up the routes/index.js and you&#8217;ll see something that looks like this:</p>

<pre class="code">exports.index = function(req, res){
  res.render('index', { title: 'Express' })
};</pre>

<p>The index is rendering a view, which we&#8217;ll learn about in the next blog post. For now, let&#8217;s modify this file to include the user route like this:</p>

<pre class="code">exports.index = function(req, res){
  res.render('index', { title: 'Express' })
};

exports.user = function(req, res) {
    res.send('Welcome to the profile of ' + req.params.user + '!');
}</pre>

<p>and also change the route specification in <tt>app.js</tt> to look like this:</p>

<pre class="code">app.get('/', routes.index);
app.get('/users/:user', routes.user);</pre>

<p>Now starting up your app should allow for both routes with the callbacks specified in a separate file!</p>

<p>Obviously, we&#8217;re more interested in having routes for all of the words we&#8217;re tracking on twitter, so go ahead and create a route called &#8216;words&#8217; that takes in a parameter. Specifically, we&#8217;d like the route &#8216;localhost:3000/words/awesome&#8217; to show us the number of times awesome has appeared, while in the callback for a word we&#8217;re not tracking it should show us &#8216;word not found&#8217;. Remember that, in order to get this working, you&#8217;ll need to <tt>require(&#8216;redis&#8217;)</tt> at the top of your express file, and create a client. If you can do this you&#8217;re doing great!</p>

<p>In the next blog post, we&#8217;ll learn how how to render views using embedded JavaScript (ejs). We&#8217;ll also learn a slightly better way of organizing route callbacks which will be more in-line with the Model-View-Controller architecture.</p>
